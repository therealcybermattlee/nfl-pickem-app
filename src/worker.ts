import { D1DatabaseManager } from '../lib/db-workers'
import * as bcrypt from 'bcryptjs'
import { SignJWT, jwtVerify } from 'jose'
import { 
  handleSSEStream, 
  handleEventPolling, 
  EventSystem, 
  EventBroadcaster 
} from './lib/event-system'

// CORS headers - restrict to known domains
const corsHeaders = {
  'Access-Control-Allow-Origin': 'https://pickem.leefamilysso.com',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
  'Access-Control-Allow-Credentials': 'true',
  // Security headers
  'X-Content-Type-Options': 'nosniff',
  'X-Frame-Options': 'DENY',
  'X-XSS-Protection': '1; mode=block',
  'Referrer-Policy': 'strict-origin-when-cross-origin'
}

interface Env {
  DB: D1Database
  JWT_SECRET?: string
  THE_ODDS_API_KEY?: string
  THE_ODDS_API_BASE_URL?: string
  CURRENT_NFL_SEASON?: string
  CURRENT_NFL_WEEK?: string
}

// TypeScript types for time-lock pick system
type PickRequest = {
  userId: string
  gameId: string
  teamId: string
}

type GameStatus = {
  id: string
  week: number
  season: number
  homeTeamId: string
  awayTeamId: string
  gameDate: string
  lockTime: string
  status: 'upcoming' | 'locked' | 'in_progress' | 'final'
  timeUntilLock: number // in milliseconds
  isLocked: boolean
  homeTeamAbbr?: string
  awayTeamAbbr?: string
}

type PickResponse = {
  id: string
  userId: string
  gameId: string
  teamId: string
  isLocked: boolean
  lockedAt?: string
  autoGenerated: boolean
  timeUntilLock: number
}

type AutoGenerateResponse = {
  success: boolean
  autoGeneratedCount: number
  gamesProcessed: number
  details: Array<{
    gameId: string
    usersGenerated: number
  }>
}

type UpdateLocksResponse = {
  success: boolean
  newlyLockedGames: number
  gameIds: string[]
  timestamp: string
}

// System monitoring types
type SystemEventLog = {
  executionId: string
  eventType: 'cron_success' | 'cron_failure' | 'game_lock_update' | 'picks_generated' | 'scores_updated' | 'api_call' | 'circuit_breaker'
  status: 'success' | 'error' | 'warning' | 'info'
  message: string
  duration?: number
  details?: string
  gamesAffected?: number
  picksGenerated?: number
  pointsAwarded?: number
}

type CircuitBreakerState = {
  isOpen: boolean
  failureCount: number
  lastFailure: number
  nextAttempt: number
}

type AutomationMetrics = {
  executionId: string
  startTime: number
  gamesChecked: number
  gamesLocked: number
  gameScoresUpdated: number
  gamesCompleted: number
  picksGenerated: number
  pointsAwarded: number
  espnApiCalls: number
  espnApiFailures: number
  errors: string[]
}

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    const url = new URL(request.url)
    const { pathname } = url
    
    // Initialize database manager
    const db = new D1DatabaseManager(env.DB)
    
    // Handle CORS preflight
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders })
    }
    
    try {
      // API Routes
      if (pathname.startsWith('/api/')) {
        const response = await handleApiRequest(request, pathname, db, env)
        Object.entries(corsHeaders).forEach(([key, value]) => {
          response.headers.set(key, value)
        })
        return response
      }
      
      // Serve static files or return 404
      return new Response('Not Found', { status: 404 })
      
    } catch (error) {
      console.error('Worker error:', error)
      return new Response(
        JSON.stringify({ error: 'Internal Server Error', details: error instanceof Error ? error.message : 'Unknown error' }), 
        { 
          status: 500, 
          headers: { 'Content-Type': 'application/json', ...corsHeaders } 
        }
      )
    }
  },

  async scheduled(controller: ScheduledController, env: Env, ctx: ExecutionContext): Promise<void> {
    const startTime = Date.now()
    const executionId = crypto.randomUUID()
    
    console.log(`ü§ñ Cron automation triggered: ${controller.scheduledTime} (ID: ${executionId})`)
    
    try {
      // Initialize database manager
      const db = new D1DatabaseManager(env.DB)
      
      // Run the complete game state automation workflow
      await gameStateAutomation(db, env, ctx, executionId, startTime)
      
    } catch (error) {
      console.error('‚ùå Critical scheduled task error:', error)
      
      // Log the failure
      try {
        const db = new D1DatabaseManager(env.DB)
        await logSystemEvent(db, {
          executionId,
          eventType: 'cron_failure',
          status: 'error',
          message: error instanceof Error ? error.message : 'Unknown error',
          duration: Date.now() - startTime,
          details: JSON.stringify({ error: String(error) })
        })
      } catch (logError) {
        console.error('Failed to log error:', logError)
      }
      
      throw error // This will be logged by Cloudflare Workers
    }
  }
}

async function handleApiRequest(request: Request, pathname: string, db: D1DatabaseManager, env: Env): Promise<Response> {
  const method = request.method
  const url = new URL(request.url)
  
  // Teams API
  if (pathname === '/api/teams') {
    if (method === 'GET') {
      const teams = await db.getAllTeams()
      return new Response(JSON.stringify(teams), {
        headers: { 'Content-Type': 'application/json' }
      })
    }
  }
  
  // Games API
  if (pathname === '/api/games') {
    if (method === 'GET') {
      const week = parseInt(url.searchParams.get('week') || env.CURRENT_NFL_WEEK || '1')
      const season = parseInt(url.searchParams.get('season') || env.CURRENT_NFL_SEASON || '2025')
      
      const games = await db.getGamesWithDetails(week, season)
      return new Response(JSON.stringify(games), {
        headers: { 'Content-Type': 'application/json' }
      })
    }
  }

  // Games Status API - New endpoint for lock status and countdown timers
  if (pathname === '/api/games/status') {
    if (method === 'GET') {
      return await handleGameStatus(request, db)
    }
  }

  // Games Lock Update API - Update game lock statuses
  if (pathname === '/api/games/update-locks') {
    if (method === 'POST') {
      return await handleUpdateLocks(db)
    }
  }

  // Utility endpoint to populate lockTime for existing games
  if (pathname === '/api/games/populate-lock-times') {
    if (method === 'POST') {
      return await handlePopulateLockTimes(db)
    }
  }
  
  // Picks API - Enhanced with time-lock validation
  if (pathname === '/api/picks') {
    if (method === 'GET') {
      // Get all picks for all users with lock status
      try {
        const result = await db.query(`
          SELECT p.*, u.name as userName, t.abbreviation as teamAbbr,
                 g.lockTime, g.status as gameStatus
          FROM picks p 
          JOIN users u ON p.userId = u.id 
          JOIN teams t ON p.teamId = t.id
          JOIN games g ON p.gameId = g.id
        `)
        
        const picks = await Promise.all(result.results.map(async (row: any) => ({
          gameId: row.gameId,
          userId: row.userId,
          teamId: row.teamId,
          userName: row.userName,
          teamAbbr: row.teamAbbr,
          isLocked: row.isLocked || false,
          lockedAt: row.lockedAt,
          autoGenerated: row.autoGenerated || false,
          timeUntilLock: await getTimeUntilLock(row.lockTime)
        })))
        
        return new Response(JSON.stringify({ picks }), {
          headers: { 'Content-Type': 'application/json' }
        })
      } catch (error) {
        return new Response(JSON.stringify({ picks: [] }), {
          headers: { 'Content-Type': 'application/json' }
        })
      }
    }
    
    if (method === 'POST') {
      // Parse request body to get userId (no authentication required for family app)
      const body = await request.json()
      const userId = body.userId
      
      if (!userId) {
        return new Response(JSON.stringify({ error: 'userId is required in request body' }), {
          status: 400,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        })
      }

      return await handlePickSubmission(request, db, userId, body)
    }
  }

  // Auto-generate picks for locked games
  if (pathname === '/api/picks/auto-generate') {
    if (method === 'POST') {
      return await handleAutoGeneratePicks(db)
    }
  }
  
  // Authentication API
  if (pathname === '/api/auth/register') {
    if (method === 'POST') {
      const body = await request.json() as { email: string; password: string; name?: string }
      
      // Check if user exists
      const existingUser = await db.getUserByEmail(body.email)
      if (existingUser) {
        return new Response(JSON.stringify({ error: 'User already exists' }), {
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        })
      }
      
      // Hash password
      const passwordHash = await bcrypt.hash(body.password, 12)
      
      // Create user
      const user = await db.createUser({
        email: body.email,
        name: body.name,
        passwordHash
      })
      
      // Create session token
      const token = await createJWT({ userId: user.id, email: user.email }, env)
      
      return new Response(JSON.stringify({ user, token }), {
        status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
    }
  }
  
  if (pathname === '/api/auth/signin') {
    if (method === 'POST') {
      const body = await request.json() as { email: string; password: string }
      
      // Find user
      const user = await db.getUserByEmail(body.email)
      const userPassword = user?.password || user?.passwordHash
      if (!user || !userPassword) {
        return new Response(JSON.stringify({ error: 'Invalid credentials' }), {
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        })
      }
      
      // Verify password
      const isValid = await bcrypt.compare(body.password, userPassword)
      if (!isValid) {
        return new Response(JSON.stringify({ error: 'Invalid credentials' }), {
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        })
      }
      
      // Create session token
      const token = await createJWT({ userId: user.id, email: user.email }, env)
      
      return new Response(JSON.stringify({ user: { ...user, password: undefined }, token }), {
        headers: { 'Content-Type': 'application/json' }
      })
    }
  }
  
  if (pathname === '/api/auth/session') {
    if (method === 'GET') {
      const userId = await getUserIdFromRequest(request, env)
      if (!userId) {
        return new Response(JSON.stringify({ user: null }), {
          headers: { 'Content-Type': 'application/json' }
        })
      }
      
      const user = await db.getUserById(userId)
      return new Response(JSON.stringify({ 
        user: user ? { ...user, password: undefined } : null 
      }), {
        headers: { 'Content-Type': 'application/json' }
      })
    }
  }
  
  // Leaderboard API
  if (pathname === '/api/leaderboard') {
    if (method === 'GET') {
      const week = url.searchParams.get('week')
      const season = url.searchParams.get('season')
      const requestedWeek = week ? parseInt(week) : 1
      const requestedSeason = season ? parseInt(season) : 2025

      const leaderboardData = await db.getLeaderboard(
        week ? parseInt(week) : undefined,
        season ? parseInt(season) : undefined
      )

      // Get actual completed games count for the requested week/season
      const completedGamesResult = await db.db.prepare(`
        SELECT COUNT(*) as count
        FROM games
        WHERE week = ? AND season = ? AND isCompleted = 1
      `).bind(requestedWeek, requestedSeason).first()

      const actualCompletedGames = completedGamesResult?.count || 0

      // Transform to match TypeScript Leaderboard interface
      const structuredResponse = {
        week: requestedWeek,
        season: requestedSeason,
        entries: Array.isArray(leaderboardData) ? leaderboardData.map((row: any, index: number) => ({
          user: {
            id: row.userId || row.id || index + 1,
            name: row.userName || row.name || `User ${index + 1}`,
            email: row.email || `${row.userName || row.name || `user${index + 1}`}@example.com`,
            displayName: row.userName || row.name || `User ${index + 1}`
          },
          position: index + 1,
          // Use weekly points when viewing a specific week, season points for season view
          points: week ? (row.weeklyPoints || 0) : (row.totalSeasonPoints || 0),
          weeklyPoints: row.weeklyPoints || 0,
          totalSeasonPoints: row.totalSeasonPoints || 0,
          totalPicks: row.totalPicks || 0,
          weeklyPicks: row.weeklyPicks || 0,
          totalGames: row.totalGames || 16,
          winPercentage: week ? (row.weeklyPercentage || 0) : (row.seasonPercentage || 0),
          weeklyPercentage: row.weeklyPercentage || 0,
          seasonPercentage: row.seasonPercentage || 0,
          streak: row.streak || 0,
          lastWeekPoints: row.weeklyPoints || 0
        })) : [],
        totalGames: 16,
        completedGames: actualCompletedGames
      }
      
      return new Response(JSON.stringify(structuredResponse), {
        headers: { 'Content-Type': 'application/json' }
      })
    }
  }


  // Odds API sync - secured system endpoint
  if (pathname === '/api/odds/sync') {
    if (method === 'POST') {
      // Require API key for system operations
      const apiKey = request.headers.get('x-api-key') || url.searchParams.get('api-key')
      const isSystemSync = apiKey === 'ESPN-SYSTEM-SYNC-2025' // Allow ESPN-only system sync
      const isValidOddsKey = apiKey === env.THE_ODDS_API_KEY
      
      if (!apiKey || (!isSystemSync && !isValidOddsKey)) {
        return new Response(JSON.stringify({ error: 'Unauthorized - Invalid API key' }), {
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        })
      }
      
      try {
        const result = await syncOddsApi(db, env)
        return new Response(JSON.stringify(result), {
          headers: { 'Content-Type': 'application/json' }
        })
      } catch (error) {
        return new Response(JSON.stringify({ 
          error: 'Sync failed', 
          details: error instanceof Error ? error.message : 'Unknown error' 
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        })
      }
    }
  }

  // Manual score update trigger (for testing)
  if (pathname === '/api/scores/update') {
    if (method === 'POST') {
      try {
        console.log('Manual score update triggered via API')
        
        // Create a mock ExecutionContext for the manual trigger
        const mockCtx = {
          waitUntil: (promise: Promise<any>) => {},
          passThroughOnException: () => {}
        } as ExecutionContext
        
        // Run the automated game state update function
        const executionId = crypto.randomUUID()
        const startTime = Date.now()
        await gameStateAutomation(db, env, mockCtx, executionId, startTime)
        
        return new Response(JSON.stringify({ 
          success: true, 
          message: 'Score update completed successfully',
          timestamp: new Date().toISOString()
        }), {
          headers: { 'Content-Type': 'application/json' }
        })
      } catch (error) {
        return new Response(JSON.stringify({ 
          error: 'Score update failed', 
          details: error instanceof Error ? error.message : 'Unknown error' 
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        })
      }
    }
  }

  // System monitoring APIs
  if (pathname === '/api/system/logs') {
    if (method === 'GET') {
      try {
        const limit = parseInt(url.searchParams.get('limit') || '50')
        const eventType = url.searchParams.get('type')
        const status = url.searchParams.get('status')
        
        let query = 'SELECT * FROM system_logs WHERE 1=1'
        const params: any[] = []
        
        if (eventType) {
          query += ' AND eventType = ?'
          params.push(eventType)
        }
        
        if (status) {
          query += ' AND status = ?'  
          params.push(status)
        }
        
        query += ' ORDER BY createdAt DESC LIMIT ?'
        params.push(limit)
        
        const result = await db.db.prepare(query).bind(...params).all()
        
        return new Response(JSON.stringify({ 
          logs: result.results || [],
          count: (result.results || []).length
        }), {
          headers: { 'Content-Type': 'application/json' }
        })
      } catch (error) {
        return new Response(JSON.stringify({ 
          logs: [],
          count: 0,
          error: 'Failed to fetch system logs'
        }), {
          headers: { 'Content-Type': 'application/json' }
        })
      }
    }
  }

  // System metrics API
  if (pathname === '/api/system/metrics') {
    if (method === 'GET') {
      try {
        const hours = parseInt(url.searchParams.get('hours') || '24')
        const cutoffTime = new Date(Date.now() - (hours * 60 * 60 * 1000)).toISOString()
        
        const result = await db.db.prepare(`
          SELECT 
            eventType,
            status,
            COUNT(*) as count,
            AVG(duration) as avgDuration,
            SUM(gamesAffected) as totalGamesAffected,
            SUM(picksGenerated) as totalPicksGenerated,
            SUM(pointsAwarded) as totalPointsAwarded
          FROM system_logs 
          WHERE createdAt > ?
          GROUP BY eventType, status
          ORDER BY eventType, status
        `).bind(cutoffTime).all()
        
        return new Response(JSON.stringify({ 
          metrics: result.results || [],
          timeframe: `${hours} hours`,
          cutoffTime
        }), {
          headers: { 'Content-Type': 'application/json' }
        })
      } catch (error) {
        return new Response(JSON.stringify({ 
          error: 'Failed to fetch system metrics'
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        })
      }
    }
  }

  // Manual automation trigger (for testing)
  if (pathname === '/api/automation/trigger') {
    if (method === 'POST') {
      try {
        const body = await request.json() as { dryRun?: boolean }
        const executionId = crypto.randomUUID()
        const startTime = Date.now()
        
        console.log(`üîß Manual automation trigger (ID: ${executionId}, dry-run: ${body.dryRun})`)
        
        // Create a mock ExecutionContext for the manual trigger
        const mockCtx = {
          waitUntil: (promise: Promise<any>) => {},
          passThroughOnException: () => {}
        } as ExecutionContext
        
        // Run the automation workflow
        await gameStateAutomation(db, env, mockCtx, executionId, startTime, body.dryRun)
        
        return new Response(JSON.stringify({ 
          success: true, 
          message: body.dryRun ? 'Dry-run automation completed' : 'Manual automation completed',
          executionId,
          timestamp: new Date().toISOString()
        }), {
          headers: { 'Content-Type': 'application/json' }
        })
      } catch (error) {
        return new Response(JSON.stringify({ 
          error: 'Automation trigger failed', 
          details: error instanceof Error ? error.message : 'Unknown error' 
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        })
      }
    }
  }

  // Scheduler logs API (for monitoring) - DEPRECATED: Use /api/system/logs instead
  if (pathname === '/api/scheduler/logs') {
    if (method === 'GET') {
      try {
        const limit = parseInt(url.searchParams.get('limit') || '50')
        const result = await db.db.prepare(`
          SELECT * FROM scheduler_logs 
          ORDER BY createdAt DESC 
          LIMIT ?
        `).bind(limit).all()
        
        return new Response(JSON.stringify({ 
          logs: result.results || [],
          count: (result.results || []).length,
          deprecated: 'Use /api/system/logs instead'
        }), {
          headers: { 'Content-Type': 'application/json' }
        })
      } catch (error) {
        return new Response(JSON.stringify({ 
          logs: [],
          count: 0,
          error: 'Failed to fetch logs'
        }), {
          headers: { 'Content-Type': 'application/json' }
        })
      }
    }
  }
  
  // =============================================================================
  // REAL-TIME EVENT SYSTEM API ENDPOINTS
  // =============================================================================
  
  // Server-Sent Events (SSE) endpoint for real-time updates
  if (pathname === '/api/events/stream') {
    if (method === 'GET') {
      // Extract user ID from authorization header if present
      const authHeader = request.headers.get('authorization')
      let userId: number | undefined
      
      if (authHeader && authHeader.startsWith('Bearer ')) {
        try {
          const token = authHeader.substring(7)
          if (!env.JWT_SECRET) {
            throw new Error('JWT_SECRET not configured')
          }
          const secret = new TextEncoder().encode(env.JWT_SECRET)
          const { payload } = await jwtVerify(token, secret)
          userId = payload.userId as number
        } catch (error) {
          // Invalid token, continue as anonymous user
          console.warn('Invalid JWT token for SSE connection:', error)
        }
      }
      
      return await handleSSEStream(request, db, userId)
    }
  }
  
  // Polling endpoint for real-time events (fallback for SSE)
  if (pathname === '/api/events/poll') {
    if (method === 'GET') {
      // Extract user ID from authorization header if present
      const authHeader = request.headers.get('authorization')
      let userId: number | undefined
      
      if (authHeader && authHeader.startsWith('Bearer ')) {
        try {
          const token = authHeader.substring(7)
          if (!env.JWT_SECRET) {
            throw new Error('JWT_SECRET not configured')
          }
          const secret = new TextEncoder().encode(env.JWT_SECRET)
          const { payload } = await jwtVerify(token, secret)
          userId = payload.userId as number
        } catch (error) {
          // Invalid token, continue as anonymous user
          console.warn('Invalid JWT token for polling:', error)
        }
      }
      
      return await handleEventPolling(request, db, userId)
    }
  }
  
  // Event creation endpoint (for testing and internal use)
  if (pathname === '/api/events') {
    if (method === 'POST') {
      try {
        const eventRequest = await request.json()
        const eventSystem = new EventSystem(db)
        const event = await eventSystem.createEvent(eventRequest)
        
        return new Response(JSON.stringify({ 
          success: true, 
          event 
        }), {
          headers: { 'Content-Type': 'application/json' }
        })
      } catch (error) {
        return new Response(JSON.stringify({ 
          error: 'Failed to create event', 
          details: error instanceof Error ? error.message : 'Unknown error' 
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        })
      }
    }
  }
  
  // =============================================================================
  // REAL-TIME DATA ENDPOINTS
  // =============================================================================
  
  // Live scores endpoint
  if (pathname === '/api/games/live-scores') {
    if (method === 'GET') {
      try {
        const week = parseInt(url.searchParams.get('week') || env.CURRENT_NFL_WEEK || '1')
        const season = parseInt(url.searchParams.get('season') || env.CURRENT_NFL_SEASON || '2025')
        
        const result = await db.query(`
          SELECT g.id, g.homeTeamId, g.awayTeamId, g.homeScore, g.awayScore, 
                 g.status, g.gameTime, g.isCompleted,
                 ht.abbreviation as homeTeamAbbr, ht.name as homeTeamName,
                 at.abbreviation as awayTeamAbbr, at.name as awayTeamName
          FROM games g
          JOIN teams ht ON g.homeTeamId = ht.id
          JOIN teams at ON g.awayTeamId = at.id
          WHERE g.week = ? AND g.season = ? 
            AND (g.status = 'in_progress' OR g.status = 'final')
          ORDER BY g.gameDate
        `, [week, season])
        
        const liveGames = result.results.map((row: any) => ({
          gameId: row.id,
          homeTeam: {
            id: row.homeTeamId,
            name: row.homeTeamName,
            abbreviation: row.homeTeamAbbr,
            score: row.homeScore
          },
          awayTeam: {
            id: row.awayTeamId,
            name: row.awayTeamName,
            abbreviation: row.awayTeamAbbr,
            score: row.awayScore
          },
          status: row.status,
          gameTime: row.gameTime,
          isCompleted: row.isCompleted
        }))
        
        return new Response(JSON.stringify({ 
          liveGames,
          week,
          season,
          lastUpdated: new Date().toISOString()
        }), {
          headers: { 'Content-Type': 'application/json' }
        })
      } catch (error) {
        return new Response(JSON.stringify({ 
          liveGames: [],
          error: 'Failed to fetch live scores' 
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        })
      }
    }
  }
  
  // Live pick status endpoint
  if (pathname === '/api/picks/live-status') {
    if (method === 'GET') {
      // Requires authentication
      const authHeader = request.headers.get('authorization')
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return new Response(JSON.stringify({ error: 'Authorization required' }), {
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        })
      }
      
      try {
        const token = authHeader.substring(7)
        if (!env.JWT_SECRET) {
          throw new Error('JWT_SECRET not configured')
        }
        const secret = new TextEncoder().encode(env.JWT_SECRET)
        const { payload } = await jwtVerify(token, secret)
        const userId = payload.userId as number
        
        const week = parseInt(url.searchParams.get('week') || env.CURRENT_NFL_WEEK || '1')
        const season = parseInt(url.searchParams.get('season') || env.CURRENT_NFL_SEASON || '2025')
        
        const result = await db.query(`
          SELECT p.gameId, p.teamId, p.isLocked, p.lockedAt, p.autoGenerated,
                 g.lockTime, g.status as gameStatus,
                 t.abbreviation as teamAbbr, t.name as teamName
          FROM picks p
          JOIN games g ON p.gameId = g.id
          JOIN teams t ON p.teamId = t.id
          WHERE p.userId = ? AND g.week = ? AND g.season = ?
          ORDER BY g.gameDate
        `, [userId, week, season])
        
        const userPicks = result.results.map((row: any) => ({
          gameId: row.gameId,
          teamPicked: {
            id: row.teamId,
            name: row.teamName,
            abbreviation: row.teamAbbr
          },
          isLocked: row.isLocked,
          lockedAt: row.lockedAt,
          autoGenerated: row.autoGenerated,
          lockTime: row.lockTime,
          gameStatus: row.gameStatus
        }))
        
        return new Response(JSON.stringify({ 
          userPicks,
          userId,
          week,
          season,
          lastUpdated: new Date().toISOString()
        }), {
          headers: { 'Content-Type': 'application/json' }
        })
      } catch (error) {
        return new Response(JSON.stringify({ error: 'Invalid authorization token' }), {
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        })
      }
    }
  }
  
  // Live leaderboard endpoint
  if (pathname === '/api/leaderboard/live') {
    if (method === 'GET') {
      try {
        const week = parseInt(url.searchParams.get('week') || env.CURRENT_NFL_WEEK || '1')
        const season = parseInt(url.searchParams.get('season') || env.CURRENT_NFL_SEASON || '2025')
        
        // Get current leaderboard with live updates
        const result = await db.query(`
          WITH user_scores AS (
            SELECT 
              u.id as userId,
              u.name,
              u.email,
              COUNT(p.id) as totalPicks,
              COUNT(CASE WHEN g.isCompleted = 1 AND p.teamId = g.winnerTeamId THEN 1 END) as correctPicks,
              COUNT(CASE WHEN g.isCompleted = 1 THEN 1 END) as completedGamePicks
            FROM users u
            LEFT JOIN picks p ON u.id = p.userId
            LEFT JOIN games g ON p.gameId = g.id AND g.week = ? AND g.season = ?
            GROUP BY u.id, u.name, u.email
          )
          SELECT 
            userId,
            name,
            email,
            totalPicks,
            correctPicks,
            completedGamePicks,
            CASE 
              WHEN completedGamePicks > 0 
              THEN ROUND((correctPicks * 100.0 / completedGamePicks), 1)
              ELSE 0
            END as winPercentage,
            ROW_NUMBER() OVER (ORDER BY correctPicks DESC, winPercentage DESC) as position
          FROM user_scores
          WHERE totalPicks > 0
          ORDER BY correctPicks DESC, winPercentage DESC
        `, [week, season])
        
        const leaderboard = result.results.map((row: any) => ({
          position: row.position,
          user: {
            id: row.userId,
            name: row.name,
            email: row.email
          },
          points: row.correctPicks,
          totalPicks: row.totalPicks,
          totalGames: row.completedGamePicks,
          winPercentage: row.winPercentage
        }))
        
        return new Response(JSON.stringify({ 
          leaderboard,
          week,
          season,
          lastUpdated: new Date().toISOString(),
          isLive: true
        }), {
          headers: { 'Content-Type': 'application/json' }
        })
      } catch (error) {
        return new Response(JSON.stringify({ 
          leaderboard: [],
          error: 'Failed to fetch live leaderboard' 
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        })
      }
    }
  }
  
  return new Response('Not Found', { status: 404 })
}

// =============================================================================
// TIME-LOCK PICK SYSTEM - UTILITY FUNCTIONS AND API HANDLERS
// =============================================================================

/**
 * Check if a game is locked based on its lockTime and status
 */
async function isGameLocked(gameId: string, db: D1DatabaseManager): Promise<boolean> {
  try {
    const result = await db.query(
      `SELECT lockTime, status FROM games WHERE id = ?`,
      [gameId]
    )
    
    if (!result.results || result.results.length === 0) {
      return true // Game not found, consider locked for safety
    }
    
    const game = result.results[0] as any
    const lockTime = new Date(game.lockTime).getTime()
    const currentTime = Date.now()
    
    // Game is locked if:
    // 1. Current time has passed the lock time, OR
    // 2. Game status is not 'upcoming'
    return lockTime <= currentTime || game.status !== 'upcoming'
  } catch (error) {
    console.error('Error checking game lock status:', error)
    return true // Default to locked on error for safety
  }
}

/**
 * Check if a user can change their pick for a specific game
 */
async function canUserChangePick(userId: string, gameId: string, db: D1DatabaseManager): Promise<boolean> {
  try {
    const result = await db.query(
      `SELECT isLocked FROM picks WHERE userId = ? AND gameId = ?`,
      [userId, gameId]
    )
    
    if (!result.results || result.results.length === 0) {
      return true // No pick exists yet, so user can make one
    }
    
    const pick = result.results[0] as any
    return !pick.isLocked // User can change if pick is not locked
  } catch (error) {
    console.error('Error checking pick change permission:', error)
    return false // Default to not allowing changes on error
  }
}

/**
 * Calculate time remaining until game lock (in milliseconds)
 */
async function getTimeUntilLock(lockTime: string): Promise<number> {
  const lockTimeMs = new Date(lockTime).getTime()
  const currentTime = Date.now()
  return Math.max(lockTimeMs - currentTime, 0)
}

/**
 * Enhanced pick submission handler with time-lock validation
 */
async function handlePickSubmission(request: Request, db: D1DatabaseManager, userId: string, body?: any): Promise<Response> {
  try {
    // Use the body passed in, or parse from request if not provided (for backward compatibility)
    const pickData = body || (await request.json()) as PickRequest
    
    // Validate required fields
    if (!pickData.gameId || !pickData.teamId) {
      return new Response(JSON.stringify({ 
        error: 'Missing required fields',
        required: ['gameId', 'teamId']
      }), {
        status: 400,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      })
    }

    // Use the provided userId (no token authentication required for family app)
    if (!userId) {
      return new Response(JSON.stringify({ error: 'User ID is required' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      })
    }
    
    // Check if game is locked
    if (await isGameLocked(pickData.gameId, db)) {
      return new Response(JSON.stringify({ 
        error: 'Game is locked',
        message: 'This game is locked. Picks cannot be modified.',
        gameId: pickData.gameId
      }), {
        status: 403,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      })
    }
    
    // Check if user can change their existing pick
    if (!(await canUserChangePick(userId, pickData.gameId, db))) {
      return new Response(JSON.stringify({ 
        error: 'Pick already locked',
        message: 'Your pick for this game is already locked and cannot be changed.',
        gameId: pickData.gameId
      }), {
        status: 403,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      })
    }
    
    // Verify the team exists and is playing in this game
    const gameResult = await db.query(
      `SELECT homeTeamId, awayTeamId, lockTime FROM games WHERE id = ?`,
      [pickData.gameId]
    )
    
    if (!gameResult.results || gameResult.results.length === 0) {
      return new Response(JSON.stringify({ 
        error: 'Game not found',
        gameId: pickData.gameId
      }), {
        status: 404,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      })
    }
    
    const game = gameResult.results[0] as any
    if (pickData.teamId !== game.homeTeamId && pickData.teamId !== game.awayTeamId) {
      return new Response(JSON.stringify({ 
        error: 'Invalid team',
        message: 'Selected team is not playing in this game.',
        gameId: pickData.gameId,
        teamId: pickData.teamId
      }), {
        status: 400,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      })
    }
    
    // Insert or update the pick with lock information
    const lockedAt = new Date().toISOString()
    const pickId = `${userId}-${pickData.gameId}`
    
    await db.query(
      `INSERT OR REPLACE INTO picks 
       (id, userId, gameId, teamId, points, lockedAt, isLocked, autoGenerated, createdAt, updatedAt)
       VALUES (?, ?, ?, ?, 0, NULL, 0, 0, datetime('now'), datetime('now'))`,
      [pickId, userId, pickData.gameId, pickData.teamId]
    )
    
    const timeUntilLock = await getTimeUntilLock(game.lockTime)
    
    // Broadcast pick submission event
    try {
      const eventSystem = new EventSystem(db)
      const broadcaster = new EventBroadcaster(eventSystem)
      
      // Get team info for the event
      const teamResult = await db.query(`SELECT id, name, abbreviation FROM teams WHERE id = ?`, [pickData.teamId])
      if (teamResult.results && teamResult.results.length > 0) {
        const team = teamResult.results[0] as any
        await broadcaster.broadcastPickSubmitted(
          parseInt(userId), 
          pickData.gameId, 
          team
        )
      }
    } catch (eventError) {
      console.error('Failed to broadcast pick submission event:', eventError)
      // Don't fail the pick submission if event broadcasting fails
    }
    
    return new Response(JSON.stringify({ 
      success: true,
      pick: {
        id: pickId,
        userId: userId,
        gameId: pickData.gameId,
        teamId: pickData.teamId,
        isLocked: false,
        lockedAt: null,
        autoGenerated: false,
        timeUntilLock
      }
    }), {
      status: 201,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    })
    
  } catch (error) {
    console.error('Error submitting pick:', error)
    return new Response(JSON.stringify({ 
      error: 'Failed to save pick',
      details: error instanceof Error ? error.message : 'Unknown error'
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    })
  }
}

/**
 * Game status handler - returns games with lock status and countdown timers
 */
async function handleGameStatus(request: Request, db: D1DatabaseManager): Promise<Response> {
  try {
    const url = new URL(request.url)
    const statusFilter = url.searchParams.get('status') as GameStatus['status'] | null
    const week = url.searchParams.get('week')
    const season = url.searchParams.get('season')
    
    // Build query with optional filters
    let query = `
      SELECT g.id, g.week, g.season, g.homeTeamId, g.awayTeamId, g.gameDate, 
             g.lockTime, g.status, 
             ht.abbreviation as homeTeamAbbr, at.abbreviation as awayTeamAbbr
      FROM games g
      JOIN teams ht ON g.homeTeamId = ht.id
      JOIN teams at ON g.awayTeamId = at.id
      WHERE 1=1`
    
    const params: any[] = []
    
    if (statusFilter && ['upcoming', 'locked', 'in_progress', 'final'].includes(statusFilter)) {
      query += ` AND g.status = ?`
      params.push(statusFilter)
    }
    
    if (week) {
      query += ` AND g.week = ?`
      params.push(parseInt(week))
    }
    
    if (season) {
      query += ` AND g.season = ?`
      params.push(parseInt(season))
    }
    
    query += ` ORDER BY g.gameDate ASC`
    
    const result = await db.query(query, params)
    
    // Process each game to add time calculations
    const games: GameStatus[] = await Promise.all(
      (result.results || []).map(async (game: any) => {
        const timeUntilLock = await getTimeUntilLock(game.lockTime)
        const isLocked = await isGameLocked(game.id, db)
        
        return {
          id: game.id,
          week: game.week,
          season: game.season,
          homeTeamId: game.homeTeamId,
          awayTeamId: game.awayTeamId,
          gameDate: game.gameDate,
          lockTime: game.lockTime,
          status: game.status,
          timeUntilLock,
          isLocked,
          homeTeamAbbr: game.homeTeamAbbr,
          awayTeamAbbr: game.awayTeamAbbr
        }
      })
    )
    
    return new Response(JSON.stringify({ 
      games,
      count: games.length,
      timestamp: new Date().toISOString()
    }), {
      headers: { 'Content-Type': 'application/json' }
    })
    
  } catch (error) {
    console.error('Error fetching game statuses:', error)
    return new Response(JSON.stringify({ 
      error: 'Failed to fetch game statuses',
      details: error instanceof Error ? error.message : 'Unknown error'
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
}

/**
 * Auto-generate picks for users who haven't picked for locked games
 */
async function handleAutoGeneratePicks(db: D1DatabaseManager): Promise<Response> {
  try {
    // Find games that should be locked but may need auto-picks
    const lockedGamesResult = await db.query(`
      SELECT id, homeTeamId, awayTeamId, week, season
      FROM games 
      WHERE datetime(lockTime) <= datetime('now') 
      AND (status = 'locked' OR status = 'in_progress')
    `)
    
    const lockedGames = lockedGamesResult.results || []
    let totalAutoGenerated = 0
    const details: AutoGenerateResponse['details'] = []
    
    console.log(`Processing ${lockedGames.length} locked games for auto-pick generation`)
    
    // Process each locked game
    for (const game of lockedGames) {
      const gameData = game as any
      
      // Find users who haven't made picks for this game
      const missingPicksResult = await db.query(`
        SELECT u.id as userId, u.name as userName
        FROM users u
        LEFT JOIN picks p ON p.userId = u.id AND p.gameId = ?
        WHERE p.id IS NULL
      `, [gameData.id])
      
      const missingPicks = missingPicksResult.results || []
      let gameAutoGenerated = 0
      
      // Generate random picks for users without picks
      for (const userRow of missingPicks) {
        const userData = userRow as any
        
        // Randomly choose between home and away team
        const randomTeam = Math.random() < 0.5 ? gameData.homeTeamId : gameData.awayTeamId
        const pickId = `${userData.userId}-${gameData.id}`
        
        try {
          await db.query(`
            INSERT INTO picks (id, userId, gameId, teamId, lockedAt, isLocked, autoGenerated, points, createdAt, updatedAt)
            VALUES (?, ?, ?, ?, datetime('now'), 1, 1, 0, datetime('now'), datetime('now'))
          `, [pickId, userData.userId, gameData.id, randomTeam])
          
          gameAutoGenerated++
          totalAutoGenerated++
          
          console.log(`Auto-generated pick for ${userData.userName} (${userData.userId}) in game ${gameData.id}`)
          
        } catch (pickError) {
          console.error(`Failed to generate pick for user ${userData.userId} in game ${gameData.id}:`, pickError)
        }
      }
      
      if (gameAutoGenerated > 0) {
        details.push({
          gameId: gameData.id,
          usersGenerated: gameAutoGenerated
        })
      }
    }
    
    // Update game_locks table to mark that auto-picks have been generated
    if (totalAutoGenerated > 0) {
      await db.query(`
        UPDATE game_locks 
        SET autoPicksGenerated = 1, lastChecked = datetime('now'), updatedAt = datetime('now')
        WHERE gameId IN (
          SELECT id FROM games 
          WHERE datetime(lockTime) <= datetime('now') 
          AND (status = 'locked' OR status = 'in_progress')
        )
      `)
    }
    
    const response: AutoGenerateResponse = {
      success: true,
      autoGeneratedCount: totalAutoGenerated,
      gamesProcessed: lockedGames.length,
      details
    }
    
    return new Response(JSON.stringify(response), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    })
    
  } catch (error) {
    console.error('Error auto-generating picks:', error)
    return new Response(JSON.stringify({ 
      error: 'Failed to auto-generate picks',
      details: error instanceof Error ? error.message : 'Unknown error'
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
}

/**
 * Update game lock statuses for games that have passed their lock time
 */
async function handleUpdateLocks(db: D1DatabaseManager): Promise<Response> {
  try {
    const timestamp = new Date().toISOString()
    
    // Get games that should be locked but aren't yet
    const gamesToLockResult = await db.query(`
      SELECT id, lockTime, week, season
      FROM games 
      WHERE datetime(lockTime) <= datetime('now') 
      AND status = 'upcoming'
    `)
    
    const gamesToLock = (gamesToLockResult.results || []) as any[]
    const gameIds = gamesToLock.map(game => game.id)
    
    let newlyLockedCount = 0
    
    if (gameIds.length > 0) {
      // Update games status to 'locked'
      const updateGamesResult = await db.query(`
        UPDATE games 
        SET status = 'locked', updatedAt = datetime('now')
        WHERE datetime(lockTime) <= datetime('now') 
        AND status = 'upcoming'
      `)
      
      newlyLockedCount = updateGamesResult.changes || 0
      
      // Insert or update game_locks entries
      for (const game of gamesToLock) {
        await db.query(`
          INSERT OR REPLACE INTO game_locks 
          (id, gameId, lockTime, isLocked, lastChecked, autoPicksGenerated, createdAt, updatedAt)
          VALUES (?, ?, ?, 1, datetime('now'), 0, datetime('now'), datetime('now'))
        `, [`lock-${game.id}`, game.id, game.lockTime])
      }
      
      console.log(`Updated ${newlyLockedCount} games to locked status:`, gameIds)
    }
    
    const response: UpdateLocksResponse = {
      success: true,
      newlyLockedGames: newlyLockedCount,
      gameIds,
      timestamp
    }
    
    return new Response(JSON.stringify(response), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    })
    
  } catch (error) {
    console.error('Error updating game locks:', error)
    return new Response(JSON.stringify({ 
      error: 'Failed to update lock statuses',
      details: error instanceof Error ? error.message : 'Unknown error'
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
}

/**
 * Utility function to populate lockTime for existing games that don't have it set
 */
async function handlePopulateLockTimes(db: D1DatabaseManager): Promise<Response> {
  try {
    // Find games without lockTime set (or with NULL lockTime)
    const gamesResult = await db.query(`
      SELECT id, gameDate 
      FROM games 
      WHERE lockTime IS NULL OR lockTime = ''
    `)
    
    const games = (gamesResult.results || []) as any[]
    let updatedCount = 0
    
    for (const game of games) {
      // Calculate lock time (15 minutes before game time)
      const gameTime = new Date(game.gameDate)
      const lockTime = new Date(gameTime.getTime() - (15 * 60 * 1000))
      
      // Update the game with lockTime
      await db.query(`
        UPDATE games 
        SET lockTime = ?, updatedAt = datetime('now')
        WHERE id = ?
      `, [lockTime.toISOString(), game.id])
      
      updatedCount++
    }
    
    console.log(`Populated lockTime for ${updatedCount} games`)
    
    return new Response(JSON.stringify({
      success: true,
      message: `Successfully populated lockTime for ${updatedCount} games`,
      updatedCount,
      timestamp: new Date().toISOString()
    }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    })
    
  } catch (error) {
    console.error('Error populating lock times:', error)
    return new Response(JSON.stringify({
      error: 'Failed to populate lock times',
      details: error instanceof Error ? error.message : 'Unknown error'
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
}

// =============================================================================
// END TIME-LOCK PICK SYSTEM
// =============================================================================

// =============================================================================
// GAME STATE AUTOMATION - COMPREHENSIVE CRON SYSTEM
// =============================================================================

/**
 * Complete game state automation workflow for Cloudflare Cron triggers
 * Handles: lock updates, auto-picks, score updates, point awarding, and monitoring
 */
async function gameStateAutomation(
  db: D1DatabaseManager, 
  env: Env, 
  ctx: ExecutionContext,
  executionId: string,
  startTime: number,
  dryRun: boolean = false
): Promise<void> {
  const currentTime = new Date()
  const currentSeason = parseInt(env.CURRENT_NFL_SEASON || '2025')
  const metrics: AutomationMetrics = {
    executionId,
    startTime,
    gamesChecked: 0,
    gamesLocked: 0,
    gameScoresUpdated: 0,
    gamesCompleted: 0,
    picksGenerated: 0,
    pointsAwarded: 0,
    espnApiCalls: 0,
    espnApiFailures: 0,
    errors: []
  }
  
  console.log(`üöÄ ${dryRun ? '[DRY-RUN] ' : ''}Game state automation starting at ${currentTime.toISOString()}`)
  
  // Initialize system_logs table if it doesn't exist
  await initializeSystemTables(db)
  
  // Check if we should run based on season and schedule
  const shouldRun = await shouldRunAutomation(currentTime, currentSeason)
  if (!shouldRun.run) {
    console.log(`‚è∏Ô∏è Skipping automation: ${shouldRun.reason}`)
    await logSystemEvent(db, {
      executionId,
      eventType: 'cron_success',
      status: 'info',
      message: `Skipped: ${shouldRun.reason}`,
      duration: Date.now() - startTime
    })
    return
  }
  
  console.log(`‚úÖ Running automation: ${shouldRun.reason}`)
  
  try {
    // STEP 1: Update game lock statuses
    console.log('üìù Step 1: Updating game lock statuses...')
    const lockUpdateResult = await updateGameLocks(db, dryRun)
    metrics.gamesLocked = lockUpdateResult.newlyLockedGames
    console.log(`‚úÖ Locked ${lockUpdateResult.newlyLockedGames} games`)
    
    await logSystemEvent(db, {
      executionId,
      eventType: 'game_lock_update',
      status: 'success',
      message: `Updated locks for ${lockUpdateResult.newlyLockedGames} games`,
      gamesAffected: lockUpdateResult.newlyLockedGames
    })
    
    // STEP 2: Auto-generate picks for newly locked games
    if (lockUpdateResult.newlyLockedGames > 0) {
      console.log('üé≤ Step 2: Auto-generating picks for locked games...')
      const autoPicksResult = await generateAutoPicksForLockedGames(db, dryRun)
      metrics.picksGenerated = autoPicksResult.autoGeneratedCount
      console.log(`‚úÖ Generated ${autoPicksResult.autoGeneratedCount} auto-picks`)
      
      await logSystemEvent(db, {
        executionId,
        eventType: 'picks_generated',
        status: 'success',
        message: `Auto-generated ${autoPicksResult.autoGeneratedCount} picks`,
        picksGenerated: autoPicksResult.autoGeneratedCount
      })
    }
    
    // STEP 3: Update scores for in-progress and recently completed games
    console.log('üèà Step 3: Updating game scores...')
    const gamesNeedingUpdate = await getGamesNeedingUpdate(db, currentSeason)
    metrics.gamesChecked = gamesNeedingUpdate.length
    
    if (gamesNeedingUpdate.length > 0) {
      console.log(`Found ${gamesNeedingUpdate.length} games needing score updates`)
      
      // Use circuit breaker for ESPN API calls
      const circuitBreakerState = await getCircuitBreakerState(db)
      if (circuitBreakerState.isOpen && Date.now() < circuitBreakerState.nextAttempt) {
        console.log('‚ö° Circuit breaker is open, skipping ESPN API calls')
        await logSystemEvent(db, {
          executionId,
          eventType: 'circuit_breaker',
          status: 'warning',
          message: 'ESPN API calls skipped due to circuit breaker'
        })
      } else {
        // Fetch updated scores with retry logic
        const updatedGames = await fetchUpdatedScoresWithRetry(gamesNeedingUpdate, env, metrics, dryRun)
        
        // Process each updated game
        for (const updatedGame of updatedGames) {
          try {
            if (!dryRun) {
              const wasUpdated = await updateGameScore(db, updatedGame)
              if (wasUpdated) {
                metrics.gameScoresUpdated++
                
                // If game is completed, award points to users
                if (updatedGame.isCompleted) {
                  console.log(`üéâ Game completed: ${updatedGame.awayTeamAbbr} ${updatedGame.awayScore} - ${updatedGame.homeScore} ${updatedGame.homeTeamAbbr}`)
                  
                  const pointsThisGame = await awardPointsForCompletedGame(db, updatedGame)
                  metrics.pointsAwarded += pointsThisGame
                  metrics.gamesCompleted++
                }
              }
            } else {
              console.log(`[DRY-RUN] Would update game ${updatedGame.id}: ${updatedGame.awayTeamAbbr} ${updatedGame.awayScore} - ${updatedGame.homeScore} ${updatedGame.homeTeamAbbr}`)
              metrics.gameScoresUpdated++
              if (updatedGame.isCompleted) {
                metrics.gamesCompleted++
              }
            }
            
          } catch (error) {
            const errorMsg = `Error processing game ${updatedGame.id}: ${error}`
            console.error(errorMsg)
            metrics.errors.push(errorMsg)
          }
        }
        
        // Update circuit breaker state
        await updateCircuitBreakerState(db, metrics.espnApiFailures === 0)
      }
    }
    
    // STEP 4: Log completion metrics
    const duration = Date.now() - startTime
    const summary = [
      `Games checked: ${metrics.gamesChecked}`,
      `Games locked: ${metrics.gamesLocked}`, 
      `Picks generated: ${metrics.picksGenerated}`,
      `Scores updated: ${metrics.gameScoresUpdated}`,
      `Games completed: ${metrics.gamesCompleted}`,
      `Points awarded: ${metrics.pointsAwarded}`,
      `ESPN API calls: ${metrics.espnApiCalls}`,
      `API failures: ${metrics.espnApiFailures}`,
      `Errors: ${metrics.errors.length}`,
      `Duration: ${duration}ms`
    ]
    
    console.log(`üéØ ${dryRun ? '[DRY-RUN] ' : ''}Automation completed:`)
    summary.forEach(line => console.log(`  - ${line}`))
    
    // Log successful execution
    await logSystemEvent(db, {
      executionId,
      eventType: 'cron_success',
      status: 'success',
      message: `Automation completed successfully${dryRun ? ' (dry-run)' : ''}`,
      duration,
      details: JSON.stringify(metrics),
      gamesAffected: metrics.gamesChecked,
      picksGenerated: metrics.picksGenerated,
      pointsAwarded: metrics.pointsAwarded
    })
    
  } catch (error) {
    const duration = Date.now() - startTime
    const errorMsg = error instanceof Error ? error.message : 'Unknown error'
    console.error('üí• Critical error in game state automation:', error)
    
    // Log the error with metrics collected so far
    await logSystemEvent(db, {
      executionId,
      eventType: 'cron_failure',
      status: 'error',
      message: errorMsg,
      duration,
      details: JSON.stringify({ metrics, error: String(error) })
    })
    
    throw error // Re-throw to trigger Cloudflare Workers error logging
  }
}

// =============================================================================
// AUTOMATION SUPPORT FUNCTIONS
// =============================================================================

/**
 * Initialize system monitoring tables
 */
async function initializeSystemTables(db: D1DatabaseManager): Promise<void> {
  try {
    // Create system_logs table
    await db.db.prepare(`
      CREATE TABLE IF NOT EXISTS system_logs (
        id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
        executionId TEXT NOT NULL,
        eventType TEXT NOT NULL,
        status TEXT NOT NULL,
        message TEXT NOT NULL,
        duration INTEGER,
        details TEXT,
        gamesAffected INTEGER DEFAULT 0,
        picksGenerated INTEGER DEFAULT 0,
        pointsAwarded INTEGER DEFAULT 0,
        createdAt TEXT DEFAULT (datetime('now'))
      )
    `).run()
    
    // Create circuit_breaker_state table
    await db.db.prepare(`
      CREATE TABLE IF NOT EXISTS circuit_breaker_state (
        id TEXT PRIMARY KEY DEFAULT 'espn_api',
        isOpen INTEGER DEFAULT 0,
        failureCount INTEGER DEFAULT 0,
        lastFailure TEXT,
        nextAttempt TEXT,
        updatedAt TEXT DEFAULT (datetime('now'))
      )
    `).run()
    
    // Insert default circuit breaker state if not exists
    await db.db.prepare(`
      INSERT OR IGNORE INTO circuit_breaker_state (id, isOpen, failureCount)
      VALUES ('espn_api', 0, 0)
    `).run()
    
  } catch (error) {
    console.error('Error initializing system tables:', error)
    // Don't throw - table creation failures shouldn't stop automation
  }
}

/**
 * Log system events for monitoring and debugging
 */
async function logSystemEvent(db: D1DatabaseManager, event: SystemEventLog): Promise<void> {
  try {
    await db.db.prepare(`
      INSERT INTO system_logs (
        executionId, eventType, status, message, duration, details, 
        gamesAffected, picksGenerated, pointsAwarded
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(
      event.executionId,
      event.eventType,
      event.status,
      event.message,
      event.duration || null,
      event.details || null,
      event.gamesAffected || 0,
      event.picksGenerated || 0,
      event.pointsAwarded || 0
    ).run()
  } catch (error) {
    console.error('Failed to log system event:', error)
    // Don't throw - logging failures shouldn't break automation
  }
}

/**
 * Determine if automation should run based on time and season
 */
async function shouldRunAutomation(currentTime: Date, currentSeason: number): Promise<{ run: boolean, reason: string }> {
  const currentMonth = currentTime.getMonth() + 1 // getMonth() returns 0-11
  const currentDay = currentTime.getDay() // 0 = Sunday, 1 = Monday, etc.
  const currentHour = currentTime.getHours()
  
  // Check if we're in NFL season (September - February)
  const isNFLSeason = currentMonth >= 9 || currentMonth <= 2 // Sep-Dec or Jan-Feb
  
  if (!isNFLSeason) {
    // Outside season - run maintenance mode (less frequent)
    return { 
      run: currentHour % 6 === 0, // Every 6 hours
      reason: isNFLSeason ? 'NFL off-season maintenance mode' : 'Outside NFL season'
    }
  }
  
  // During NFL season - check game day schedule
  const isGameDay = currentDay >= 4 || currentDay <= 1 // Thu(4), Fri(5), Sat(6), Sun(0), Mon(1)
  
  if (isGameDay) {
    return {
      run: true,
      reason: `NFL season game day (${['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][currentDay]})`
    }
  } else {
    // Off game days - run less frequently
    return {
      run: currentHour % 2 === 0, // Every 2 hours
      reason: `NFL season off-day (${['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][currentDay]})`
    }
  }
}

/**
 * Update game lock statuses (wrapper around existing function with monitoring)
 */
async function updateGameLocks(db: D1DatabaseManager, dryRun: boolean = false): Promise<UpdateLocksResponse> {
  if (dryRun) {
    // In dry-run mode, just check what would be locked
    const gamesToLockResult = await db.query(`
      SELECT id, lockTime, week, season
      FROM games 
      WHERE datetime(lockTime) <= datetime('now') 
      AND status = 'upcoming'
    `)
    
    const gameIds = (gamesToLockResult.results || []).map((game: any) => game.id)
    
    return {
      success: true,
      newlyLockedGames: gameIds.length,
      gameIds,
      timestamp: new Date().toISOString()
    }
  }
  
  // Use existing handleUpdateLocks logic  
  const response = await handleUpdateLocks(db)
  return await response.json()
}

/**
 * Auto-generate picks for locked games (wrapper around existing function)
 */
async function generateAutoPicksForLockedGames(db: D1DatabaseManager, dryRun: boolean = false): Promise<AutoGenerateResponse> {
  if (dryRun) {
    // In dry-run mode, just count what would be generated
    const lockedGamesResult = await db.query(`
      SELECT id FROM games 
      WHERE datetime(lockTime) <= datetime('now') 
      AND (status = 'locked' OR status = 'in_progress')
    `)
    
    let totalWouldGenerate = 0
    for (const game of (lockedGamesResult.results || [])) {
      const gameData = game as any
      const missingPicksResult = await db.query(`
        SELECT COUNT(*) as count
        FROM users u
        LEFT JOIN picks p ON p.userId = u.id AND p.gameId = ?
        WHERE p.id IS NULL
      `, [gameData.id])
      
      totalWouldGenerate += (missingPicksResult.results?.[0] as any)?.count || 0
    }
    
    return {
      success: true,
      autoGeneratedCount: totalWouldGenerate,
      gamesProcessed: (lockedGamesResult.results || []).length,
      details: []
    }
  }
  
  // Use existing handleAutoGeneratePicks logic
  const response = await handleAutoGeneratePicks(db)
  return await response.json()
}

/**
 * Get circuit breaker state for ESPN API calls
 */
async function getCircuitBreakerState(db: D1DatabaseManager): Promise<CircuitBreakerState> {
  try {
    const result = await db.db.prepare(`
      SELECT * FROM circuit_breaker_state WHERE id = 'espn_api'
    `).first()
    
    if (!result) {
      return { isOpen: false, failureCount: 0, lastFailure: 0, nextAttempt: 0 }
    }
    
    return {
      isOpen: Boolean(result.isOpen),
      failureCount: result.failureCount || 0,
      lastFailure: result.lastFailure ? new Date(result.lastFailure).getTime() : 0,
      nextAttempt: result.nextAttempt ? new Date(result.nextAttempt).getTime() : 0
    }
  } catch (error) {
    console.error('Error getting circuit breaker state:', error)
    return { isOpen: false, failureCount: 0, lastFailure: 0, nextAttempt: 0 }
  }
}

/**
 * Update circuit breaker state based on API call results
 */
async function updateCircuitBreakerState(db: D1DatabaseManager, success: boolean): Promise<void> {
  try {
    if (success) {
      // Reset circuit breaker on success
      await db.db.prepare(`
        UPDATE circuit_breaker_state 
        SET isOpen = 0, failureCount = 0, lastFailure = NULL, nextAttempt = NULL,
            updatedAt = datetime('now')
        WHERE id = 'espn_api'
      `).run()
    } else {
      // Increment failure count
      const currentState = await getCircuitBreakerState(db)
      const newFailureCount = currentState.failureCount + 1
      const shouldOpen = newFailureCount >= 3 // Open after 3 consecutive failures
      const nextAttempt = shouldOpen ? Date.now() + (5 * 60 * 1000) : null // 5 minutes
      
      await db.db.prepare(`
        UPDATE circuit_breaker_state 
        SET isOpen = ?, failureCount = ?, lastFailure = datetime('now'), 
            nextAttempt = ?, updatedAt = datetime('now')
        WHERE id = 'espn_api'
      `).bind(
        shouldOpen ? 1 : 0,
        newFailureCount,
        nextAttempt ? new Date(nextAttempt).toISOString() : null
      ).run()
      
      if (shouldOpen) {
        console.log(`‚ö° Circuit breaker opened after ${newFailureCount} failures. Next attempt: ${new Date(nextAttempt!).toISOString()}`)
      }
    }
  } catch (error) {
    console.error('Error updating circuit breaker state:', error)
  }
}

/**
 * Fetch updated scores with retry logic and circuit breaker
 */
async function fetchUpdatedScoresWithRetry(
  games: any[], 
  env: Env, 
  metrics: AutomationMetrics,
  dryRun: boolean = false
): Promise<any[]> {
  if (dryRun) {
    // In dry-run mode, simulate API calls
    console.log(`[DRY-RUN] Would make ESPN API calls for ${games.length} games`)
    return games.map(game => ({
      ...game,
      homeScore: Math.floor(Math.random() * 35),
      awayScore: Math.floor(Math.random() * 35),
      isCompleted: Math.random() > 0.7 // 30% chance game is completed
    }))
  }
  
  const maxRetries = 3
  let attempt = 0
  
  while (attempt < maxRetries) {
    try {
      attempt++
      metrics.espnApiCalls++
      
      console.log(`üì° ESPN API call attempt ${attempt}/${maxRetries}`)
      
      const updatedGames = await fetchUpdatedScoresFromESPN(games)
      console.log(`‚úÖ ESPN API success: ${updatedGames.length} games updated`)
      
      return updatedGames
      
    } catch (error) {
      metrics.espnApiFailures++
      const errorMsg = `ESPN API attempt ${attempt} failed: ${error}`
      console.error(errorMsg)
      metrics.errors.push(errorMsg)
      
      if (attempt >= maxRetries) {
        console.error(`‚ùå All ESPN API attempts failed after ${maxRetries} retries`)
        throw error
      }
      
      // Wait before retry (exponential backoff)
      const waitTime = Math.min(1000 * Math.pow(2, attempt - 1), 10000) // 1s, 2s, 4s max 10s
      console.log(`‚è≥ Waiting ${waitTime}ms before retry...`)
      await new Promise(resolve => setTimeout(resolve, waitTime))
    }
  }
  
  return []
}

/**
 * Get games that need score updates (in progress or recently completed)
 */
async function getGamesNeedingUpdate(db: D1DatabaseManager, season: number): Promise<any[]> {
  const now = new Date()
  
  // Get games that:
  // 1. Are scheduled to start in the last 6 hours (might be in progress)
  // 2. Are not completed yet
  // 3. Or were completed in the last 2 hours (for final score verification)
  const sixHoursAgo = new Date(now.getTime() - (6 * 60 * 60 * 1000))
  
  try {
    // First check what columns exist by trying a simple query
    const tableInfo = await db.db.prepare(`PRAGMA table_info(games)`).all()
    console.log('Games table columns:', tableInfo.results?.map((col: any) => col.name).join(', '))
    
    // For now, get all games from current season that aren't completed or were recently completed
    const result = await db.db.prepare(`
      SELECT g.*, 
             ht.abbreviation as homeTeamAbbr, 
             at.abbreviation as awayTeamAbbr
      FROM games g
      JOIN teams ht ON g.homeTeamId = ht.id
      JOIN teams at ON g.awayTeamId = at.id
      WHERE g.season = ? 
      AND (
        -- Games that should be in progress (not completed)
        (g.gameDate >= ? AND g.isCompleted = 0)
        OR
        -- All completed games (we'll filter for recent ones in code)
        (g.isCompleted = 1)
      )
      ORDER BY g.gameDate ASC
    `).bind(
      season,
      sixHoursAgo.toISOString()
    ).all()
    
    return result.results || []
  } catch (error) {
    console.error('Error getting games needing update:', error)
    return []
  }
}

/**
 * Fetch updated scores from ESPN API for specific games
 */
async function fetchUpdatedScoresFromESPN(games: any[]): Promise<any[]> {
  const updatedGames: any[] = []
  
  // Group games by week for efficient API calls
  const gamesByWeek = games.reduce((acc: {[key: number]: any[]}, game) => {
    if (!acc[game.week]) acc[game.week] = []
    acc[game.week].push(game)
    return acc
  }, {})
  
  // Fetch ESPN data for each week
  for (const [week, weekGames] of Object.entries(gamesByWeek)) {
    try {
      const espnGames = await fetchESPNGamesForWeek(parseInt(week), weekGames[0].season)
      
      // Match ESPN games with our games and extract updates
      for (const ourGame of weekGames) {
        const espnGame = espnGames.find((eg: any) => 
          eg.homeTeamId === ourGame.homeTeamAbbr && 
          eg.awayTeamId === ourGame.awayTeamAbbr
        )
        
        if (espnGame) {
          // Check if scores have changed or game status changed
          const hasScoreUpdate = 
            espnGame.homeScore !== ourGame.homeScore ||
            espnGame.awayScore !== ourGame.awayScore ||
            (espnGame.isCompleted && !ourGame.isCompleted) ||
            (espnGame.status === 'final' && !ourGame.isCompleted)
          
          if (hasScoreUpdate) {
            updatedGames.push({
              ...ourGame,
              homeScore: espnGame.homeScore,
              awayScore: espnGame.awayScore,
              status: espnGame.status,
              isCompleted: espnGame.isCompleted || espnGame.status === 'final',
              winnerTeamId: getWinnerTeamId(espnGame, ourGame)
            })
          }
        }
      }
      
    } catch (error) {
      console.error(`Error fetching ESPN data for week ${week}:`, error)
      // Continue with other weeks
    }
  }
  
  return updatedGames
}

/**
 * Normalize ESPN API status to our expected format (database constraint: lowercase)
 */
function normalizeESPNStatus(espnStatus: string): string {
  switch (espnStatus) {
    case 'STATUS_FINAL':
      return 'final'
    case 'STATUS_IN_PROGRESS':
      return 'in_progress'
    case 'STATUS_SCHEDULED':
      return 'upcoming'
    case 'STATUS_POSTPONED':
      return 'upcoming' // Map postponed to upcoming for now
    case 'STATUS_SUSPENDED':
      return 'in_progress' // Map suspended to in_progress
    default:
      // Fallback: remove STATUS_ prefix and lowercase
      const normalized = espnStatus.replace('STATUS_', '').toLowerCase()
      // Map common variations to valid database values
      if (normalized === 'final') return 'final'
      if (normalized === 'completed') return 'final'
      if (normalized === 'in_progress' || normalized === 'inprogress') return 'in_progress'
      if (normalized === 'locked') return 'locked'
      return 'upcoming' // Default fallback
  }
}

/**
 * Fetch ESPN games for a specific week (optimized version of existing function)
 */
async function fetchESPNGamesForWeek(week: number, season: number): Promise<any[]> {
  const url = `https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?seasontype=2&week=${week}&dates=${season}`
  
  const response = await fetch(url)
  if (!response.ok) {
    throw new Error(`ESPN API error: ${response.status}`)
  }
  
  const data = await response.json()
  
  if (!data.events || !Array.isArray(data.events)) {
    return []
  }
  
  return data.events.map((event: any) => {
    const competition = event.competitions?.[0]
    const competitors = competition?.competitors || []
    
    const homeCompetitor = competitors.find((comp: any) => comp.homeAway === 'home')
    const awayCompetitor = competitors.find((comp: any) => comp.homeAway === 'away')
    
    return {
      id: event.id,
      status: normalizeESPNStatus(competition?.status?.type?.name || 'SCHEDULED'),
      isCompleted: competition?.status?.type?.completed || false,
      homeTeamId: homeCompetitor?.team?.abbreviation,
      awayTeamId: awayCompetitor?.team?.abbreviation,
      homeScore: homeCompetitor?.score ? parseInt(homeCompetitor.score) : null,
      awayScore: awayCompetitor?.score ? parseInt(awayCompetitor.score) : null
    }
  })
}

/**
 * Update game score in the database
 */
async function updateGameScore(db: D1DatabaseManager, updatedGame: any): Promise<boolean> {
  try {
    // First try with updatedAt column, fall back to without it if column doesn't exist
    let result;
    try {
      result = await db.db.prepare(`
        UPDATE games 
        SET homeScore = ?, 
            awayScore = ?, 
            isCompleted = ?,
            status = ?,
            winnerTeamId = ?,
            updatedAt = datetime('now')
        WHERE id = ?
      `).bind(
        updatedGame.homeScore,
        updatedGame.awayScore,
        updatedGame.isCompleted ? 1 : 0,
        updatedGame.status || 'upcoming',
        updatedGame.winnerTeamId,
        updatedGame.id
      ).run()
    } catch (columnError) {
      // If updatedAt column doesn't exist, update without it
      console.log('updatedAt column not found, updating without it')
      result = await db.db.prepare(`
        UPDATE games 
        SET homeScore = ?, 
            awayScore = ?, 
            isCompleted = ?,
            status = ?,
            winnerTeamId = ?
        WHERE id = ?
      `).bind(
        updatedGame.homeScore,
        updatedGame.awayScore,
        updatedGame.isCompleted ? 1 : 0,
        updatedGame.status || 'upcoming',
        updatedGame.winnerTeamId,
        updatedGame.id
      ).run()
    }
    
    return result.changes > 0
    
  } catch (error) {
    console.error(`Error updating game ${updatedGame.id}:`, error)
    return false
  }
}

/**
 * Award points to users for a completed game
 */
async function awardPointsForCompletedGame(db: D1DatabaseManager, completedGame: any): Promise<number> {
  if (!completedGame.winnerTeamId) {
    console.log(`No winner determined for game ${completedGame.id}, skipping point awards`)
    return 0
  }
  
  try {
    // Get all picks for this game - check if already scored
    const picks = await db.db.prepare(`
      SELECT p.*, u.name as userName, t.abbreviation as teamAbbr
      FROM picks p
      JOIN users u ON p.userId = u.id
      JOIN teams t ON p.teamId = t.id
      WHERE p.gameId = ?
    `).bind(completedGame.id).all()
    
    if (!picks.results || picks.results.length === 0) {
      console.log(`No picks found for game ${completedGame.id}`)
      return 0
    }
    
    // Check if this game has already been scored (defensive check)
    const alreadyScored = picks.results.every(pick => pick.isCorrect !== null)
    if (alreadyScored) {
      console.log(`Game ${completedGame.id} already scored, skipping`)
      return 0
    }
    
    let pointsAwarded = 0
    
    // Award points to correct picks
    for (const pick of picks.results) {
      const isCorrect = pick.teamId === completedGame.winnerTeamId
      const points = isCorrect ? 1 : 0
      
      // Update pick with points and correctness
      try {
        await db.db.prepare(`
          UPDATE picks 
          SET points = ?, 
              isCorrect = ?,
              updatedAt = datetime('now')
          WHERE id = ?
        `).bind(points, isCorrect ? 1 : 0, pick.id).run()
      } catch (columnError) {
        // If updatedAt column doesn't exist in picks table, update without it
        await db.db.prepare(`
          UPDATE picks 
          SET points = ?, 
              isCorrect = ?
          WHERE id = ?
        `).bind(points, isCorrect ? 1 : 0, pick.id).run()
      }
      
      if (isCorrect) {
        pointsAwarded++
        console.log(`Awarded 1 point to ${pick.userName} for picking ${pick.teamAbbr}`)
      }
    }
    
    console.log(`Total points awarded for game ${completedGame.id}: ${pointsAwarded}/${picks.results.length}`)
    return pointsAwarded
    
  } catch (error) {
    console.error(`Error awarding points for game ${completedGame.id}:`, error)
    return 0
  }
}

/**
 * Determine the winner team ID based on scores
 */
function getWinnerTeamId(espnGame: any, ourGame: any): string | null {
  if (!espnGame.homeScore || !espnGame.awayScore) return null
  
  const homeScore = parseInt(espnGame.homeScore)
  const awayScore = parseInt(espnGame.awayScore)
  
  if (homeScore > awayScore) {
    return ourGame.homeTeamId
  } else if (awayScore > homeScore) {
    return ourGame.awayTeamId
  }
  
  // Tie game - no winner
  return null
}

/**
 * Log scheduler execution for monitoring
 */
async function logSchedulerExecution(db: D1DatabaseManager, metrics: any): Promise<void> {
  try {
    // Create scheduler_logs table if it doesn't exist
    await db.db.prepare(`
      CREATE TABLE IF NOT EXISTS scheduler_logs (
        id TEXT PRIMARY KEY,
        executionTime TEXT NOT NULL,
        gamesChecked INTEGER DEFAULT 0,
        gamesUpdated INTEGER DEFAULT 0,
        gamesCompleted INTEGER DEFAULT 0,
        pointsAwarded INTEGER DEFAULT 0,
        duration INTEGER DEFAULT 0,
        createdAt TEXT DEFAULT (datetime('now'))
      )
    `).run()
    
    // Insert execution log
    await db.db.prepare(`
      INSERT INTO scheduler_logs (id, executionTime, gamesChecked, gamesUpdated, gamesCompleted, pointsAwarded, duration)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `).bind(
      crypto.randomUUID(),
      metrics.executionTime.toISOString(),
      metrics.gamesChecked,
      metrics.gamesUpdated,
      metrics.gamesCompleted,
      metrics.pointsAwarded,
      metrics.duration
    ).run()
    
  } catch (error) {
    console.error('Error logging scheduler execution:', error)
    // Don't throw - logging failures shouldn't break the scheduler
  }
}

async function getUserIdFromRequest(request: Request, env: Env): Promise<string | null> {
  try {
    const authHeader = request.headers.get('Authorization')
    if (!authHeader?.startsWith('Bearer ')) {
      return null
    }
    
    const token = authHeader.substring(7)
    const payload = await verifyJWT(token, env)
    return payload.userId as string
  } catch {
    return null
  }
}

async function createJWT(payload: any, env: Env): Promise<string> {
  if (!env.JWT_SECRET) {
    throw new Error('JWT_SECRET not configured')
  }
  const secret = new TextEncoder().encode(env.JWT_SECRET)
  
  return await new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('24h')
    .sign(secret)
}

async function verifyJWT(token: string, env: Env): Promise<any> {
  if (!env.JWT_SECRET) {
    throw new Error('JWT_SECRET not configured')
  }
  const secret = new TextEncoder().encode(env.JWT_SECRET)
  
  const { payload } = await jwtVerify(token, secret)
  return payload
}

function calculateNFLWeek(gameDate: Date, season: number): number {
  // NFL 2025 season starts approximately September 4, 2025 (Thursday Night Football)
  // Week 1 games are typically played September 4-8, 2025
  const seasonStart = new Date(2025, 8, 4) // September 4, 2025 (month is 0-indexed)
  
  // Calculate days since season start
  const daysSinceStart = Math.floor((gameDate.getTime() - seasonStart.getTime()) / (1000 * 60 * 60 * 24))
  
  // Each NFL week is 7 days, starting Thursday
  // Week 1: Sep 4-10, Week 2: Sep 11-17, etc.
  const week = Math.floor(daysSinceStart / 7) + 1
  
  // Clamp to valid NFL weeks (1-18 regular season + 4 playoff weeks)
  return Math.max(1, Math.min(22, week))
}

async function syncOddsApi(db: D1DatabaseManager, env: Env): Promise<any> {
  const season = parseInt(env.CURRENT_NFL_SEASON || '2025')
  
  // Fetch from both ESPN and The Odds API
  const espnGames = await fetchESPNGames(season)
  const oddsGames = env.THE_ODDS_API_KEY ? await fetchOddsApiGames(env) : []

  console.log(`ESPN API: ${espnGames.length} games, Odds API: ${oddsGames.length} games`)

  // DO NOT DELETE EXISTING GAMES - this would cascade delete all picks!
  // Instead, we'll update existing games and insert new ones
  console.log(`Syncing games for season ${season} (preserving existing picks)`)

  let gamesInserted = 0
  const weekCounts: { [key: number]: number } = {}
  
  // Process all ESPN games (primary source for schedule/teams)
  console.log(`Processing all ${espnGames.length} ESPN games`)
  
  for (const espnGame of espnGames) {
    try {
      console.log(`Processing game: ${espnGame.awayTeamId} @ ${espnGame.homeTeamId}`)
      
      // Find teams by abbreviation (ESPN already provides abbreviations)
      const homeTeam = await findTeamByName(db, espnGame.homeTeamId)
      const awayTeam = await findTeamByName(db, espnGame.awayTeamId)

      if (!homeTeam || !awayTeam) {
        console.warn(`Could not find teams: ${espnGame.homeTeamId} vs ${espnGame.awayTeamId}`)
        continue
      }

      const calculatedWeek = espnGame.week
      weekCounts[calculatedWeek] = (weekCounts[calculatedWeek] || 0) + 1

      // ESPN data is primary - only supplement with Odds API if ESPN data is missing
      let homeSpread = espnGame.homeSpread
      let overUnder = espnGame.overUnder
      let oddsProvider = 'ESPN'

      // Only use Odds API to fill in missing ESPN data
      if ((!homeSpread || !overUnder) && oddsGames.length > 0) {
        const oddsMatch = oddsGames.find((og: any) => 
          og.homeTeamId === espnGame.homeTeamId && og.awayTeamId === espnGame.awayTeamId
        )
        
        if (oddsMatch) {
          // Only use Odds API data if ESPN doesn't have it
          if (!homeSpread && oddsMatch.homeSpread) {
            homeSpread = oddsMatch.homeSpread
            console.log(`Using Odds API spread for ${espnGame.homeTeamId} game`)
          }
          if (!overUnder && oddsMatch.overUnder) {
            overUnder = oddsMatch.overUnder
            console.log(`Using Odds API over/under for ${espnGame.homeTeamId} game`)
          }
          // Mark as mixed source if we used any Odds API data
          if ((!espnGame.homeSpread && oddsMatch.homeSpread) || (!espnGame.overUnder && oddsMatch.overUnder)) {
            oddsProvider = 'ESPN + The Odds API'
          }
        }
      }

      // Calculate lock time (15 minutes before game time for picks to lock)
      const gameTime = new Date(espnGame.gameDate)
      const lockTime = new Date(gameTime.getTime() - (15 * 60 * 1000)) // 15 minutes before kickoff
      
      // UPSERT: Insert new games or update existing ones (preserves picks!)
      // Use INSERT OR REPLACE to update game data without deleting picks
      await db.db.prepare(`
        INSERT OR REPLACE INTO games (
          id, espnId, week, season, homeTeamId, awayTeamId, gameDate, lockTime,
          status, isCompleted, homeScore, awayScore, homeSpread, overUnder,
          oddsProvider, oddsUpdatedAt
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `).bind(
        espnGame.id || crypto.randomUUID(),
        espnGame.id, // ESPN ID for reference
        calculatedWeek,
        season,
        homeTeam.id, // Use team UUID, not abbreviation
        awayTeam.id, // Use team UUID, not abbreviation
        espnGame.gameDate,
        lockTime.toISOString(), // Lock time for picks
        'upcoming', // Default status for new games
        espnGame.status === 'FINAL' || espnGame.status === 'COMPLETED',
        espnGame.homeScore,
        espnGame.awayScore,
        homeSpread ? homeSpread / 100 : null, // Convert from cents to decimal
        overUnder ? overUnder / 100 : null,   // Convert from cents to decimal
        oddsProvider,
        new Date().toISOString()
      ).run()

      gamesInserted++
      console.log(`Inserted: ${awayTeam.abbreviation} @ ${homeTeam.abbreviation} (Week ${calculatedWeek}) ${espnGame.status}`)

    } catch (error) {
      console.error(`Error processing game ${espnGame.homeTeamId} vs ${espnGame.awayTeamId}:`, error)
    }
  }

  console.log('Games by week:', weekCounts)

  return {
    success: true,
    message: `Successfully synced ${gamesInserted} games for Season ${season} across ${Object.keys(weekCounts).length} weeks`,
    dataSources: {
      espn: espnGames.length,
      odds: oddsGames.length,
      matches: gamesInserted
    },
    gamesInserted,
    weekBreakdown: weekCounts
  }
}

/**
 * BULLETPROOF TEAM MAPPING - Eliminates database corruption
 * 
 * Key principles:
 * - Exact abbreviation matching only (ESPN provides exact abbreviations) 
 * - Explicit mapping for known edge cases
 * - Fail-fast approach (better to fail than corrupt data)
 * - Zero fuzzy matching that causes cross-contamination
 */
async function findTeamByName(db: D1DatabaseManager, teamName: string): Promise<any> {
  const normalized = teamName.trim().toUpperCase()
  console.log(`Looking for team: "${teamName}" (normalized: "${normalized}")`)
  
  // 1. EXACT ABBREVIATION MATCH (Primary - ESPN provides abbreviations)
  const exactMatch = await db.db.prepare(
    'SELECT * FROM teams WHERE abbreviation = ?'
  ).bind(normalized).first()
  if (exactMatch) {
    console.log(`‚úÖ Found exact match: ${exactMatch.name} (${exactMatch.abbreviation})`)
    return exactMatch
  }
  
  // 2. EXPLICIT TEAM MAPPING (Secondary - Handle known variations)
  const teamMappings: Record<string, string> = {
    // Los Angeles teams (common confusion)
    'LAR': 'LAR', 'LA': 'LAR',     // Los Angeles Rams
    'LAC': 'LAC',                   // Los Angeles Chargers
    // Legacy/alternate names  
    'NE': 'NE',                     // New England Patriots
    'NO': 'NO',                     // New Orleans Saints
    'SF': 'SF',                     // San Francisco 49ers
    'TB': 'TB',                     // Tampa Bay Buccaneers
    'KC': 'KC',                     // Kansas City Chiefs
    'GB': 'GB',                     // Green Bay Packers
    'LV': 'LV', 'LAS': 'LV',       // Las Vegas Raiders (was Oakland)
    'WAS': 'WAS', 'WSH': 'WAS'     // Washington Commanders
  }
  
  const mappedAbbr = teamMappings[normalized]
  if (mappedAbbr && mappedAbbr !== normalized) {
    const mappedMatch = await db.db.prepare(
      'SELECT * FROM teams WHERE abbreviation = ?'
    ).bind(mappedAbbr).first()
    if (mappedMatch) {
      console.log(`‚úÖ Found mapped match: ${mappedMatch.name} (${mappedMatch.abbreviation})`)
      return mappedMatch
    }
  }
  
  // 3. FAIL FAST - No fuzzy matching that causes corruption
  console.error(`‚ùå TEAM MAPPING FAILED: No exact match for "${teamName}" (${normalized})`)
  console.error(`Available abbreviations should exactly match ESPN API values`)
  return null
}

async function fetchESPNGames(season: number): Promise<any[]> {
  try {
    console.log(`Fetching ESPN games for full season ${season}`)
    
    const allGames: any[] = []
    
    // Fetch all 18 regular season weeks
    for (let week = 1; week <= 18; week++) {
      try {
        console.log(`Fetching ESPN data for Week ${week}`)
        
        // ESPN API endpoint for NFL scoreboard data
        const url = `https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?seasontype=2&week=${week}&dates=${season}`
        
        const response = await fetch(url)
        if (!response.ok) {
          console.warn(`ESPN API error for Week ${week}: ${response.status}`)
          continue
        }
        
        const data = await response.json()
        console.log(`ESPN API Week ${week}: ${data.events?.length || 0} games found`)
        
        if (data.events && Array.isArray(data.events)) {
          // Transform ESPN data to our format
          const weekGames = data.events.map((event: any) => {
            const competition = event.competitions?.[0]
            const competitors = competition?.competitors || []
            
            // Find home and away teams
            const homeCompetitor = competitors.find((comp: any) => comp.homeAway === 'home')
            const awayCompetitor = competitors.find((comp: any) => comp.homeAway === 'away')
            
            // Extract odds if available
            const odds = competition?.odds?.[0]
            const overUnder = odds?.overUnder ? Math.round(odds.overUnder * 100) : null
            const homeSpread = odds?.spread ? Math.round(odds.spread * 100) : null
            
            // Robust team identification with multiple fallbacks
            const homeTeamId = homeCompetitor?.team?.abbreviation || homeCompetitor?.team?.name || homeCompetitor?.team?.displayName
            const awayTeamId = awayCompetitor?.team?.abbreviation || awayCompetitor?.team?.name || awayCompetitor?.team?.displayName
            
            // Log team extraction for debugging
            console.log(`Game ${event.id}: ${awayTeamId} @ ${homeTeamId}`)
            
            if (!homeTeamId || !awayTeamId) {
              console.warn(`Missing team data for game ${event.id}: home=${homeTeamId}, away=${awayTeamId}`)
            }
            
            return {
              id: event.id,
              season: season,
              week: week,
              gameDate: event.date,
              status: competition?.status?.type?.name || 'SCHEDULED',
              homeTeamId: homeTeamId,
              awayTeamId: awayTeamId,
              homeScore: homeCompetitor?.score ? parseInt(homeCompetitor.score) : null,
              awayScore: awayCompetitor?.score ? parseInt(awayCompetitor.score) : null,
              homeSpread: homeSpread,
              overUnder: overUnder,
              source: 'ESPN'
            }
          })
          
          allGames.push(...weekGames)
        }
        
        // Add small delay between requests to be respectful
        await new Promise(resolve => setTimeout(resolve, 100))
        
      } catch (weekError) {
        console.error(`Error fetching Week ${week}:`, weekError)
        continue
      }
    }
    
    console.log(`Processed ${allGames.length} total games from ESPN API across all weeks`)
    return allGames
    
  } catch (error) {
    console.error('Error fetching ESPN games:', error)
    return []
  }
}

async function fetchOddsApiGames(env: Env): Promise<any[]> {
  try {
    console.log('Fetching odds from The Odds API')
    
    const url = `https://api.the-odds-api.com/v4/sports/americanfootball_nfl/odds/?apiKey=${env.THE_ODDS_API_KEY}&regions=us&markets=spreads,totals&oddsFormat=american&dateFormat=iso`
    
    const response = await fetch(url)
    if (!response.ok) {
      throw new Error(`Odds API error: ${response.status}`)
    }
    
    const data = await response.json()
    console.log(`Odds API response: ${data?.length || 0} games found`)
    
    if (!Array.isArray(data)) {
      console.log('No valid odds data found')
      return []
    }
    
    // Transform Odds API data to our format
    const games = data.map((game: any) => {
      const homeTeam = game.home_team
      const awayTeam = game.away_team
      
      // Extract spread and total from bookmakers
      let homeSpread = null
      let overUnder = null
      
      if (game.bookmakers && game.bookmakers.length > 0) {
        const bookmaker = game.bookmakers[0] // Use first bookmaker
        
        // Find spread market
        const spreadMarket = bookmaker.markets?.find((m: any) => m.key === 'spreads')
        if (spreadMarket && spreadMarket.outcomes) {
          const homeOutcome = spreadMarket.outcomes.find((o: any) => o.name === homeTeam)
          if (homeOutcome && homeOutcome.point) {
            homeSpread = Math.round(homeOutcome.point * 100)
          }
        }
        
        // Find totals market
        const totalsMarket = bookmaker.markets?.find((m: any) => m.key === 'totals')
        if (totalsMarket && totalsMarket.outcomes && totalsMarket.outcomes[0]) {
          overUnder = Math.round(totalsMarket.outcomes[0].point * 100)
        }
      }
      
      return {
        id: game.id,
        gameDate: game.commence_time,
        homeTeamId: homeTeam,
        awayTeamId: awayTeam,
        homeSpread: homeSpread,
        overUnder: overUnder,
        source: 'TheOddsAPI'
      }
    })
    
    console.log(`Processed ${games.length} games from Odds API`)
    return games
    
  } catch (error) {
    console.error('Error fetching odds:', error)
    return []
  }
}
import { describe, it, expect, vi, beforeEach, afterEach, beforeAll, afterAll } from 'vitest'
import { unstable_dev } from 'wrangler'
import type { UnstableDevWorker } from 'wrangler'

describe('Time-Lock API Tests', () => {
  let worker: UnstableDevWorker
  let db: any
  
  const mockCurrentTime = new Date('2025-09-07T12:00:00.000Z').getTime()
  const testUser = 'test-user-123'
  const testGameId = 'test-game-456'
  const testTeamId = 'test-team-789'
  
  beforeAll(async () => {
    worker = await unstable_dev('src/worker.ts', {
      experimental: { disableExperimentalWarning: true },
      env: {
        NEXTAUTH_SECRET: 'test-secret-key-for-jwt-signing',
        THE_ODDS_API_KEY: 'test-odds-api-key'
      }
    })
  })
  
  afterAll(async () => {
    await worker.stop()
  })
  
  beforeEach(async () => {
    vi.setSystemTime(mockCurrentTime)
    
    // Set up test data
    await setupTestData()
  })
  
  afterEach(() => {
    vi.useRealTimers()
  })
  
  async function setupTestData() {
    // Create test user
    await worker.fetch('http://localhost/api/test/setup', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'create_user',
        userId: testUser,
        email: 'test@example.com'
      })
    })
    
    // Create test teams
    await worker.fetch('http://localhost/api/test/setup', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'create_team',
        teamId: testTeamId,
        name: 'Test Team',
        abbreviation: 'TEST'
      })
    })
    
    // Create test game
    const futureGameTime = new Date(mockCurrentTime + 2 * 60 * 60 * 1000) // 2 hours future
    await worker.fetch('http://localhost/api/test/setup', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'create_game',
        gameId: testGameId,
        homeTeamId: testTeamId,
        awayTeamId: testTeamId,
        gameTime: futureGameTime.toISOString(),
        lockTime: new Date(futureGameTime.getTime() - 60 * 60 * 1000).toISOString(), // 1 hour before
        status: 'upcoming'
      })
    })
  }

  describe('Pick Submission Time-Lock Logic', () => {
    it('should allow pick submission for unlocked games', async () => {
      const response = await worker.fetch('http://localhost/api/picks/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: testUser,
          gameId: testGameId,
          teamId: testTeamId
        })
      })
      
      expect(response.status).toBe(201)
      
      const result = await response.json()
      expect(result.success).toBe(true)
      expect(result.pick).toHaveValidPickFormat()
      expect(result.pick.isLocked).toBe(true) // Pick is locked immediately after submission
      expect(result.pick.autoGenerated).toBe(false)
    })

    it('should reject pick submission for locked games', async () => {
      // Move time to after lock time
      vi.setSystemTime(mockCurrentTime + 90 * 60 * 1000) // 1.5 hours (past lock time)
      
      const response = await worker.fetch('http://localhost/api/picks/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: testUser,
          gameId: testGameId,
          teamId: testTeamId
        })
      })
      
      expect(response.status).toBe(403)
      
      const result = await response.json()
      expect(result.error).toBe('Game is locked')
      expect(result.message).toContain('locked')
      expect(result.gameId).toBe(testGameId)
    })

    it('should handle race condition at exact lock time', async () => {
      // Set time to exactly lock time
      const lockTime = new Date(mockCurrentTime + 60 * 60 * 1000).getTime() // Exactly at lock time
      vi.setSystemTime(lockTime)
      
      const response = await worker.fetch('http://localhost/api/picks/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: testUser,
          gameId: testGameId,
          teamId: testTeamId
        })
      })
      
      // Should be locked at exact time
      expect(response.status).toBe(403)
    })

    it('should prevent changing already locked picks', async () => {
      // Submit initial pick
      await worker.fetch('http://localhost/api/picks/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: testUser,
          gameId: testGameId,
          teamId: testTeamId
        })
      })
      
      // Try to change the pick
      const response = await worker.fetch('http://localhost/api/picks/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: testUser,
          gameId: testGameId,
          teamId: 'different-team-id'
        })
      })
      
      expect(response.status).toBe(403)
      
      const result = await response.json()
      expect(result.error).toBe('Pick already locked')
    })

    it('should validate team is playing in the game', async () => {
      const response = await worker.fetch('http://localhost/api/picks/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: testUser,
          gameId: testGameId,
          teamId: 'non-existent-team'
        })
      })
      
      expect(response.status).toBe(400)
      
      const result = await response.json()
      expect(result.error).toContain('Invalid team')
    })

    it('should validate required fields', async () => {
      const response = await worker.fetch('http://localhost/api/picks/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: testUser,
          // Missing gameId and teamId
        })
      })
      
      expect(response.status).toBe(400)
      
      const result = await response.json()
      expect(result.error).toBe('Missing required fields')
      expect(result.required).toEqual(['userId', 'gameId', 'teamId'])
    })
  })

  describe('Game Status API', () => {
    it('should return correct game status for upcoming games', async () => {
      const response = await worker.fetch(`http://localhost/api/games/status?gameId=${testGameId}`)
      
      expect(response.status).toBe(200)
      
      const result = await response.json()
      expect(result.success).toBe(true)
      expect(result.games).toHaveLength(1)
      
      const game = result.games[0]
      expect(game.status).toBe('upcoming')
      expect(game.isLocked).toBe(false)
      expect(game.timeUntilLock).toBeGreaterThan(0)
    })

    it('should return correct game status for locked games', async () => {
      // Move time to after lock time
      vi.setSystemTime(mockCurrentTime + 90 * 60 * 1000) // 1.5 hours
      
      const response = await worker.fetch(`http://localhost/api/games/status?gameId=${testGameId}`)
      
      expect(response.status).toBe(200)
      
      const result = await response.json()
      const game = result.games[0]
      expect(game.status).toBe('locked')
      expect(game.isLocked).toBe(true)
      expect(game.timeUntilLock).toBe(0)
    })

    it('should handle multiple games status request', async () => {
      // Create another test game
      const secondGameId = 'test-game-2'
      const nearFutureTime = new Date(mockCurrentTime + 30 * 60 * 1000) // 30 minutes
      
      await worker.fetch('http://localhost/api/test/setup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'create_game',
          gameId: secondGameId,
          homeTeamId: testTeamId,
          awayTeamId: testTeamId,
          gameTime: nearFutureTime.toISOString(),
          lockTime: new Date(nearFutureTime.getTime() - 15 * 60 * 1000).toISOString(), // 15 min before
          status: 'upcoming'
        })
      })
      
      const response = await worker.fetch('http://localhost/api/games/status')
      
      expect(response.status).toBe(200)
      
      const result = await response.json()
      expect(result.games.length).toBeGreaterThanOrEqual(2)
      
      // Should have both upcoming and locked games
      const statuses = result.games.map((g: any) => g.status)
      expect(statuses).toContain('upcoming')
    })
  })

  describe('Auto Pick Generation', () => {
    it('should generate auto picks for locked games with missing picks', async () => {
      // Move time past lock time
      vi.setSystemTime(mockCurrentTime + 90 * 60 * 1000) // 1.5 hours
      
      const response = await worker.fetch('http://localhost/api/picks/auto-generate', {
        method: 'POST'
      })
      
      expect(response.status).toBe(200)
      
      const result = await response.json()
      expect(result.success).toBe(true)
      expect(result.autoGeneratedCount).toBeGreaterThan(0)
      expect(result.gamesProcessed).toBeGreaterThan(0)
    })

    it('should not generate duplicate auto picks', async () => {
      // Move time past lock time
      vi.setSystemTime(mockCurrentTime + 90 * 60 * 1000) // 1.5 hours
      
      // Generate picks first time
      await worker.fetch('http://localhost/api/picks/auto-generate', {
        method: 'POST'
      })
      
      // Try to generate again
      const response = await worker.fetch('http://localhost/api/picks/auto-generate', {
        method: 'POST'
      })
      
      expect(response.status).toBe(200)
      
      const result = await response.json()
      expect(result.autoGeneratedCount).toBe(0) // Should be 0 since picks already exist
    })

    it('should support dry-run mode for auto pick generation', async () => {
      // Move time past lock time
      vi.setSystemTime(mockCurrentTime + 90 * 60 * 1000) // 1.5 hours
      
      const response = await worker.fetch('http://localhost/api/picks/auto-generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ dryRun: true })
      })
      
      expect(response.status).toBe(200)
      
      const result = await response.json()
      expect(result.success).toBe(true)
      // Should report what would be generated without actually generating
      expect(result.autoGeneratedCount).toBeGreaterThan(0)
      
      // Verify no actual picks were created
      const picksResponse = await worker.fetch(`http://localhost/api/picks?userId=${testUser}&gameId=${testGameId}`)
      const picks = await picksResponse.json()
      expect(picks.picks).toHaveLength(0)
    })
  })

  describe('Game Lock Updates', () => {
    it('should update game lock status when time passes', async () => {
      const response = await worker.fetch('http://localhost/api/locks/update', {
        method: 'POST'
      })
      
      expect(response.status).toBe(200)
      
      const result = await response.json()
      expect(result.success).toBe(true)
      expect(result.newlyLockedGames).toBe(0) // No games should be locked yet
    })

    it('should lock games when lock time is reached', async () => {
      // Move time past lock time
      vi.setSystemTime(mockCurrentTime + 90 * 60 * 1000) // 1.5 hours
      
      const response = await worker.fetch('http://localhost/api/locks/update', {
        method: 'POST'
      })
      
      expect(response.status).toBe(200)
      
      const result = await response.json()
      expect(result.success).toBe(true)
      expect(result.newlyLockedGames).toBeGreaterThan(0)
      expect(result.gameIds).toContain(testGameId)
    })

    it('should support dry-run mode for lock updates', async () => {
      // Move time past lock time
      vi.setSystemTime(mockCurrentTime + 90 * 60 * 1000) // 1.5 hours
      
      const response = await worker.fetch('http://localhost/api/locks/update', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ dryRun: true })
      })
      
      expect(response.status).toBe(200)
      
      const result = await response.json()
      expect(result.success).toBe(true)
      expect(result.newlyLockedGames).toBeGreaterThan(0)
      
      // Verify game status wasn't actually changed
      const statusResponse = await worker.fetch(`http://localhost/api/games/status?gameId=${testGameId}`)
      const status = await statusResponse.json()
      expect(status.games[0].status).toBe('upcoming') // Should still be upcoming
    })
  })

  describe('Concurrent Operations', () => {
    it('should handle multiple simultaneous pick submissions', async () => {
      const promises = []
      
      // Create multiple users
      for (let i = 0; i < 5; i++) {
        const userId = `concurrent-user-${i}`
        await worker.fetch('http://localhost/api/test/setup', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'create_user',
            userId,
            email: `user${i}@example.com`
          })
        })
        
        // Submit picks simultaneously
        promises.push(
          worker.fetch('http://localhost/api/picks/submit', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              userId,
              gameId: testGameId,
              teamId: testTeamId
            })
          })
        )
      }
      
      const responses = await Promise.all(promises)
      
      // All submissions should succeed
      for (const response of responses) {
        expect(response.status).toBe(201)
        const result = await response.json()
        expect(result.success).toBe(true)
      }
    })

    it('should handle race condition between pick submission and game locking', async () => {
      // Set time very close to lock time
      vi.setSystemTime(mockCurrentTime + 59 * 60 * 1000 + 59 * 1000) // 59 minutes 59 seconds
      
      const [pickResponse, lockResponse] = await Promise.all([
        worker.fetch('http://localhost/api/picks/submit', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            userId: testUser,
            gameId: testGameId,
            teamId: testTeamId
          })
        }),
        worker.fetch('http://localhost/api/locks/update', {
          method: 'POST'
        })
      ])
      
      // One operation should succeed, timing dependent
      expect([200, 201, 403]).toContain(pickResponse.status)
      expect(lockResponse.status).toBe(200)
    })
  })

  describe('Error Handling', () => {
    it('should handle database connection errors gracefully', async () => {
      // This test would need special setup to simulate DB failures
      // Mock or temporarily break the database connection
      
      const response = await worker.fetch('http://localhost/api/picks/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: 'nonexistent-user',
          gameId: 'nonexistent-game',
          teamId: 'nonexistent-team'
        })
      })
      
      expect([400, 404, 500]).toContain(response.status)
    })

    it('should handle malformed JSON requests', async () => {
      const response = await worker.fetch('http://localhost/api/picks/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: 'invalid-json{{'
      })
      
      expect(response.status).toBe(400)
    })

    it('should handle oversized requests', async () => {
      const largePayload = {
        userId: testUser,
        gameId: testGameId,
        teamId: testTeamId,
        extraData: 'x'.repeat(10000) // 10KB of extra data
      }
      
      const response = await worker.fetch('http://localhost/api/picks/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(largePayload)
      })
      
      // Should either accept it or reject with appropriate status
      expect([201, 413]).toContain(response.status)
    })
  })

  describe('Time Zone Handling', () => {
    it('should handle different timezone inputs correctly', async () => {
      // Create game with different timezone formats
      const gameId = 'timezone-test-game'
      const gameTimeUTC = new Date(mockCurrentTime + 2 * 60 * 60 * 1000)
      const gameTimeEST = new Date(gameTimeUTC.getTime() - 5 * 60 * 60 * 1000) // EST offset
      
      await worker.fetch('http://localhost/api/test/setup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'create_game',
          gameId,
          homeTeamId: testTeamId,
          awayTeamId: testTeamId,
          gameTime: gameTimeUTC.toISOString(),
          lockTime: new Date(gameTimeUTC.getTime() - 60 * 60 * 1000).toISOString(),
          status: 'upcoming'
        })
      })
      
      const response = await worker.fetch(`http://localhost/api/games/status?gameId=${gameId}`)
      const result = await response.json()
      
      expect(result.success).toBe(true)
      expect(result.games[0].timeUntilLock).toBeWithinTimeRange(60 * 60 * 1000, 1000) // ~1 hour ±1 second
    })
  })

  describe('Performance', () => {
    it('should handle bulk operations efficiently', async () => {
      const startTime = performance.now()
      
      // Create 100 games and check their status
      const gameIds = []
      for (let i = 0; i < 100; i++) {
        const gameId = `perf-test-game-${i}`
        gameIds.push(gameId)
        
        await worker.fetch('http://localhost/api/test/setup', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'create_game',
            gameId,
            homeTeamId: testTeamId,
            awayTeamId: testTeamId,
            gameTime: new Date(mockCurrentTime + (i + 1) * 60 * 1000).toISOString(),
            lockTime: new Date(mockCurrentTime + i * 60 * 1000).toISOString(),
            status: 'upcoming'
          })
        })
      }
      
      // Query all games status
      const response = await worker.fetch('http://localhost/api/games/status')
      const result = await response.json()
      
      const endTime = performance.now()
      const duration = endTime - startTime
      
      expect(response.status).toBe(200)
      expect(result.games.length).toBeGreaterThanOrEqual(100)
      expect(duration).toBeLessThan(5000) // Should complete in under 5 seconds
    })
  })
})